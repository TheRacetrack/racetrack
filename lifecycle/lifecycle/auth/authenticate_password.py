"""
This file reimplements password authentication logic from Django==4.2.17
See site-packages/django/contrib/auth/__init__.py
"""

from lifecycle.database.schema.tables import User
from lifecycle.server.cache import LifecycleCache
from racetrack_client.log.errors import EntityNotFound

from lifecycle.auth.hasher import get_hasher, get_random_string, make_password

UNUSABLE_PASSWORD_SUFFIX_LENGTH = 40
UNUSABLE_PASSWORD_PREFIX = "!"

def authenticate(username=None, password=None):
    """
    If the given credentials are valid, return a User object.
    """
    try:
        user = authenticate_user(username, password)
    except PermissionDenied:
        return None

    return user

def authenticate_user(username=None, password=None):
        if username is None or password is None:
            return
        try:
            user: User = LifecycleCache.record_mapper().find_one(User, username=username)
        except EntityNotFound:
            # Run the default password hasher once to reduce the timing
            # difference between an existing and a nonexistent user (#20760).

            make_password(password)
        else:
            def setter(raw_password):
                user.password = make_password(raw_password)
                LifecycleCache.record_mapper().update(user)

            if check_password(password, user.password, setter) and user.is_active:
                return user


class PermissionDenied(Exception):
    """The user did not have permission to do that"""
    pass


def check_password(password, encoded, setter=None):
    """
    Return a boolean of whether the raw password matches the three
    part encoded digest.

    If setter is specified, it'll be called when you need to
    regenerate the password.
    """
    fake_runtime = password is None or not is_password_usable(encoded)

    preferred = get_hasher()
    try:
        hasher = identify_hasher(encoded)
    except ValueError:
        # encoded is gibberish or uses a hasher that's no longer installed.
        fake_runtime = True

    if fake_runtime:
        # Run the default password hasher once to reduce the timing difference
        # between an existing user with an unusable password and a nonexistent
        # user or missing hasher (similar to #20760).
        make_password(get_random_string(UNUSABLE_PASSWORD_SUFFIX_LENGTH))
        return False

    hasher_changed = hasher.algorithm != preferred.algorithm
    must_update = hasher_changed or preferred.must_update(encoded)
    is_correct = hasher.verify(password, encoded)

    # If the hasher didn't change (we don't protect against enumeration if it
    # does) and the password should get updated, try to close the timing gap
    # between the work factor of the current encoded password and the default
    # work factor.
    if not is_correct and not hasher_changed and must_update:
        hasher.harden_runtime(password, encoded)

    if setter and is_correct and must_update:
        setter(password)
    return is_correct


def is_password_usable(encoded):
    """
    Return True if this password wasn't generated by
    User.set_unusable_password(), i.e. make_password(None).
    """
    return encoded is None or not encoded.startswith(UNUSABLE_PASSWORD_PREFIX)


def identify_hasher(encoded):
    """
    Only one hasher supported at the moment. If new hashers are added, 
    consult `check_password` implementation to ensure smooth transition.
    """
    return get_hasher()
