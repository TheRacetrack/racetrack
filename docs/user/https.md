# Racetrack behind HTTPS
This document explains how to serve Racetrack behind a secure HTTPS protocol.

It requires having valid TLS certificate. There are multiple options to get one:

- create use self-signed certificate - not recommended as it is insecure and vulnerable to man-in-the-middle attacks
- obtain it from your Certificate Authority - you can create your own CA cert and install it on all your devices.
- use Let's Encrypt to obtain a free certificate - usually they're valid for 90 days, and it requires seting up a certbot to renew the certificate automatically
- use other certificate generated by a trusted third-party service

Keep in mind that a securely signed certificate is usually issued for a registered DNS domain name, not an IP address.
Working with certificates also entails setting up a correct renewal process to update them before they expire.

## TLS Termination
Usual practice is to separate the concerns into 2 tasks that can be done separately by different teams:
- setting up the core application (using HTTP) - not accessible from the outside, developers don't need to worry about implementing TLS properly
- handling TLS termination at the edge - a secure HTTPS gateway at the system's first public entry point.

## Self-signed certificate in local Kubernetes
To create a custom self-signed TLS certificate for use on an HTTPS server, follow these steps:

1.  Generate a private key and a certificate request:
    ```sh
    openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj "/CN=ingress.local/O=nginxsvc"
    ```

2.  Create a Kubernetes secret:
    ```sh
    kubectl create secret tls tls-secret --namespace=racetrack --key tls.key --cert tls.crt
    ```
    
    Keep in mind that self-signed certificates are not trusted by browsers and will trigger security warnings.
    They are suitable for development and testing purposes, but not recommended for production environments.
    
    For production use, it's best to obtain a certificate from a trusted Certificate Authority (CA). However, if you need to use a self-signed certificate in a controlled environment, you can create your own root CA and use it to sign your server certificates. This approach allows you to install the root CA certificate on client machines to avoid security warnings.

3.  Create an Ingress Controller:
    ```sh
    kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/cloud/deploy.yaml
    ```
    
    Optional: If you're running Kubernetes in a local environment (like Minikube or Kind), you may need to patch the ingress-nginx-controller service to use NodePort:
    ```sh
    kubectl patch svc ingress-nginx-controller -n ingress-nginx -p '{"spec": {"type": "NodePort", "ports": [{"nodePort": 30443, "port": 443, "targetPort": 443, "protocol": "TCP", "name": "https"}]}}'
    ```

4.  Create Ingress in a `ingress.yaml` file.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  namespace: racetrack
  name: nginx-test
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  tls:
    - hosts:
      - ingress.local
      secretName: tls-secret
  ingressClassName: nginx
  rules:
  - http:
      paths:
      - path: /lifecycle
        pathType: Prefix
        backend:
          service:
            name: lifecycle
            port:
              number: 7002
      - path: /lifecycle-supervisor
        pathType: Prefix
        backend:
          service:
            name: lifecycle-supervisor
            port:
              number: 7006
      - path: /image-builder
        pathType: Prefix
        backend:
          service:
            name: image-builder
            port:
              number: 7001
      - path: /dashboard
        pathType: Prefix
        backend:
          service:
            name: dashboard
            port:
              number: 7003
      - path: /pub
        pathType: Prefix
        backend:
          service:
            name: pub
            port:
              number: 7005
      - path: /prometheus
        pathType: Prefix
        backend:
          service:
            name: prometheus
            port:
              number: 9090
      - path: /grafana
        pathType: Prefix
        backend:
          service:
            name: grafana
            port:
              number: 3000
```

Apply it to Kubernetes:
```sh
kubectl apply -f ingress.yaml
```

Now you should be able to access the application at https://127.0.0.1/dashboard.

For more details, check out
[TLS Termination with Ingress-Nginx Controller](https://kubernetes.github.io/ingress-nginx/examples/tls-termination/)
